---
title: P9183-FEB-USACO
date: 2025-08-28 12:08:33
tags: 提高
categories: 信息竞赛
mathjax: true
---
[传送门](https://www.luogu.com.cn/problem/P9183)

# 题目

# P9183 [USACO23OPEN] FEB B

## 题目描述

贝西和埃尔希正在密谋最终推翻他们的主人——农夫约翰！他们通过 $N$ 条短信进行计划。他们的对话可以用一个长度为 $N$ 的字符串 $S$ 来表示。     
其中 $S_i$ 是字母 ```B``` 或 ```E```，这意味着第 $i$ 条消息分别由贝西或埃尔希发送的。


然而，农夫约翰听说了这个消息，并试图拦截他们的谈话。因此，字符串 $S$ 的一些字母是 ```F```，这意味着农夫约翰混淆了信息，发件人未知（贝西、埃尔希都有可能）。   
**注：约翰没有发送信息！他只是在干扰奶牛间的通话！**


未混淆对话的兴奋程度是**一只奶牛重复发送信息的次数**。也就是说，子串 ```BB``` 或 ```EE``` 在 $S$ 中出现的次数。你想找到原始信息的兴奋程度，但你不知道约翰的信息中哪一条实际上是贝西或埃尔希的。在所有可能的情况下，**从小到大输出**所有可能的兴奋程度。

## 输入格式

第一行：一个整数 $N$（通话长度）。       
第二行：一个字符串 $S$（通话内容）。

## 输出格式

第一行：输出一个整数 $K$，为**不同**兴奋程度的可能数量。   
随后 $K$ 行：每行一个整数，为每种兴奋程度。**注意按照从小到大的顺序输出。**

## 输入输出样例 #1

### 输入 #1

```
4
BEEF
```

### 输出 #1

```
2
1
2
```

## 输入输出样例 #2

### 输入 #2

```
9
FEBFEBFEB
```

### 输出 #2

```
2
2
3
```

## 输入输出样例 #3

### 输入 #3

```
10
BFFFFFEBFE
```

### 输出 #3

```
3
2
4
6
```

## 说明/提示

$1 \le N \le 2 \times 10^5$。
- 测试点 4~8：$N \le 10$
- 测试点 9~20：无额外限制。

---

# 题解

### 1. 题意快速回顾
给定一条由 `B/E/F` 组成的字符串 `S`（长度为 `n`）。  
每个 `F` 可以被替换成 `B` 或 `E`。  
对所有可能的替换方案，求相邻字符相同（即出现 `BB` 或 `EE`）的对数，并把**所有不同的结果**从小到大输出。

---

### 2. 变量说明
```cpp
int n;          // 字符串长度
string s,t;     // s 原始串；t 用来构造“最小方案”
int l = 0;      // 最小可能的对数（首项）
int r;          // 最大可能的对数（末项）
int d;          // 公差：1 或 2，由首尾字符决定
```

---

### 3. 公差 `d`
```cpp
int d = 2 - (s[0]=='F' || s[n-1]=='F');
```
- 若首字符或末字符为 `F`，则公差为 **1**；否则为 **2**。

---

### 4. 跳过前缀 `F`
```cpp
for(r=0;r<n-1&&s[r]=='F';r++);
```
- 让 `r` 指向第一个 **非 `F`** 的位置，作为后续扫描起点。

---

### 5. 扫描字符串，构造两种极端方案
```cpp
for(int i = r+1; i < n; ++i) {
    if(s[i] == 'F') {
        t[i] = t[i-1];                 // 最小方案：尽量让相邻不同
        s[i] = (s[i-1] == 'E' ? 'B' : 'E'); // 最大方案：尽量让相邻相同
    }
    l += (s[i] == s[i-1]);            // 最大方案累加相同对
    r += (t[i] == t[i-1]);            // 最小方案累加相同对
}
```
- 对每一个位置：
  - **最小方案** `t`：把 `F` 设成与前一位相同，**尽量不同** → 得到最小对数 `l`。
  - **最大方案** `s`：把 `F` 设成与前一位相反，**尽量相同** → 得到最大对数 `r`。

---

### 6. 输出等差数列
```cpp
cout << (r - l) / d + 1 << '\n';
for (int i = l; i <= r; i += d) cout << i << '\n';
```
- 从 `l` 到 `r`，步长为 `d`，输出所有可能的兴奋程度。

---

### 7. 结论
- 所有可行结果恰好构成 **等差数列**，首项 `l`，末项 `r`，公差 `d`。  
- 代码一次性构造两端，直接输出即可。

---

# 参考代码

``` cpp
#include<bits/stdc++.h>
using namespace std;
 
int n;
string s,t;
 
int main(){
    cin>>n>>s;
    t=s;
    int l=0;
    int r;
    int d=2-(s[0]=='F'||s[n-1]=='F');
    for(r=0;r<n-1&&s[r]=='F';r++);
    for(int i=r+1;i<n;i++){
        if(s[i]=='F'){
            t[i]=t[i-1];s[i]=(s[i-1]=='E'?'B':'E'); 
        }
        l+=(s[i]==s[i-1]);
        r+=(t[i]==t[i-1]); 
    } 
    cout<<(r-l)/d+1<<'\n';
    for(int i=l;i<=r;i+=d) cout<<i<<'\n';
    return 0;
}
```

